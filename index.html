<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pokédex TCG</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Google Fonts: Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- Custom Styles -->
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d1117; /* Cor de fundo principal (cinza escuro/azulado) */
        }
        /* Estilização da barra de rolagem */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #1c2128;
        }
        ::-webkit-scrollbar-thumb {
            background: #4a5568;
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #718096;
        }
        /* Classes de borda para status */
        .status-border-favorito { border-color: #FBBF24 !important; } /* Dourado */
        .status-border-capturado { border-color: #34D399 !important; } /* Verde */
        .status-border-desejo { border-color: #A78BFA !important; } /* Roxo */

        /* Animação de carregamento */
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #facc15;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200">

    <!-- Header -->
    <header class="bg-gray-800/80 backdrop-blur-sm sticky top-0 z-40 shadow-lg">
        <div class="container mx-auto px-4 py-3">
            <div class="flex flex-col sm:flex-row justify-between items-center gap-4">
                <h1 class="text-2xl font-bold text-yellow-400">Pokédex TCG</h1>
                <div class="w-full sm:w-auto sm:max-w-xs">
                    <input type="search" id="search-input" placeholder="Buscar por nome ou número..." class="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-2 focus:outline-none focus:ring-2 focus:ring-yellow-400 transition">
                </div>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="container mx-auto p-4">
        <!-- Navigation Tabs -->
        <div id="tabs" class="flex space-x-2 sm:space-x-4 border-b border-gray-700 mb-4">
            <button data-tab="all" class="tab-btn font-semibold py-2 px-4 border-b-2 border-transparent hover:border-yellow-400 transition">Todos</button>
            <button data-tab="favorites" class="tab-btn font-semibold py-2 px-4 border-b-2 border-transparent hover:border-yellow-400 transition">Favoritos</button>
            <button data-tab="captured" class="tab-btn font-semibold py-2 px-4 border-b-2 border-transparent hover:border-yellow-400 transition">Capturados</button>
            <button data-tab="wishlist" class="tab-btn font-semibold py-2 px-4 border-b-2 border-transparent hover:border-yellow-400 transition">Desejo</button>
        </div>

        <!-- Controls -->
        <div class="flex flex-wrap gap-4 items-center mb-6">
            <select id="sort-select" class="bg-gray-700 border border-gray-600 rounded-lg px-3 py-2 focus:outline-none focus:ring-2 focus:ring-yellow-400">
                <option value="pokedex_number">Ordenar por Número</option>
                <option value="alphabetical">Ordenar por Nome</option>
            </select>
            <button id="filter-btn" class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-lg transition">Filtros</button>
            <div id="pagination-controls" class="flex items-center gap-2 ml-auto"></div>
        </div>
        
        <!-- Loading Indicator -->
        <div id="loading" class="flex justify-center items-center h-64">
             <div class="loader"></div>
        </div>

        <!-- Pokémon Grid -->
        <div id="pokedex-grid" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 gap-4">
            <!-- Pokémon cards will be inserted here by JavaScript -->
        </div>
    </main>

    <!-- Back to Top Button -->
    <button id="back-to-top" class="hidden fixed bottom-5 right-5 bg-yellow-400 hover:bg-yellow-500 text-gray-900 font-bold p-3 rounded-full shadow-lg transition-opacity">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 15l7-7 7 7" />
        </svg>
    </button>

    <!-- Modals -->
    <!-- Filter Modal -->
    <div id="filter-modal" class="hidden fixed inset-0 bg-black bg-opacity-70 z-50 flex justify-center items-center p-4">
        <div class="bg-gray-800 rounded-lg shadow-xl w-full max-w-md p-6">
            <h3 class="text-xl font-bold mb-4 text-yellow-400">Filtros Avançados</h3>
            <div class="space-y-4">
                <div>
                    <label class="font-semibold block mb-2">Geração</label>
                    <div id="generation-filters" class="grid grid-cols-3 gap-2">
                        <!-- Generation buttons will be inserted here -->
                    </div>
                </div>
                <div>
                    <label class="font-semibold block mb-2">Tipo</label>
                    <div id="type-filters" class="grid grid-cols-3 gap-2">
                        <!-- Type buttons will be inserted here -->
                    </div>
                </div>
            </div>
            <div class="mt-6 flex justify-end gap-3">
                <button id="reset-filters-btn" class="bg-gray-600 hover:bg-gray-700 text-white font-semibold py-2 px-4 rounded-lg transition">Limpar</button>
                <button id="apply-filters-btn" class="bg-yellow-400 hover:bg-yellow-500 text-gray-900 font-semibold py-2 px-4 rounded-lg transition">Aplicar</button>
            </div>
        </div>
    </div>

    <!-- Image Viewer Modal -->
    <div id="image-viewer-modal" class="hidden fixed inset-0 bg-black bg-opacity-80 z-50 flex justify-center items-center p-4" onclick="this.classList.add('hidden')">
        <img id="fullscreen-image" src="" alt="Pokémon Card Fullscreen" class="max-w-full max-h-full object-contain rounded-lg">
    </div>

    <!-- Version Switcher Panel -->
    <div id="version-switcher-panel" class="hidden fixed inset-0 bg-black bg-opacity-70 z-50 flex justify-center items-center p-4">
        <div class="bg-gray-800 rounded-lg shadow-xl w-full max-w-4xl p-6">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-xl font-bold text-yellow-400">Escolha uma Versão da Carta</h3>
                <button id="close-version-switcher" class="text-gray-400 hover:text-white">&times;</button>
            </div>
            <div id="version-grid" class="grid grid-cols-3 sm:grid-cols-4 md:grid-cols-5 gap-4 max-h-[70vh] overflow-y-auto">
                <!-- Card versions will be inserted here -->
            </div>
        </div>
    </div>

    <!-- Firebase SDK -->
    <script type="module">
        // Importações do Firebase
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, onSnapshot } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- CONFIGURAÇÃO ---
        const POKEAPI_BASE_URL = 'https://pokeapi.co/api/v2';
        const TCG_API_BASE_URL = 'https://api.pokemontcg.io/v2/cards';
        const TCG_API_KEY = ''; // Adicione sua chave aqui se necessário

        const GENERATIONS = {
            1: { limit: 151, offset: 0 }, 2: { limit: 100, offset: 151 },
            3: { limit: 135, offset: 251 }, 4: { limit: 107, offset: 386 },
            5: { limit: 156, offset: 493 }, 6: { limit: 72, offset: 649 },
            7: { limit: 88, offset: 721 }, 8: { limit: 96, offset: 809 },
            9: { limit: 105, offset: 905 }
        };

        const TYPES = [
            'Grass', 'Fire', 'Water', 'Lightning', 'Psychic', 'Fighting', 'Darkness', 'Metal', 'Dragon', 'Fairy', 'Colorless', 'Normal'
        ];

        // --- ELEMENTOS DO DOM ---
        const grid = document.getElementById('pokedex-grid');
        const searchInput = document.getElementById('search-input');
        const sortSelect = document.getElementById('sort-select');
        const tabs = document.getElementById('tabs');
        const loadingIndicator = document.getElementById('loading');
        const filterBtn = document.getElementById('filter-btn');
        const filterModal = document.getElementById('filter-modal');
        const applyFiltersBtn = document.getElementById('apply-filters-btn');
        const resetFiltersBtn = document.getElementById('reset-filters-btn');
        const generationFiltersContainer = document.getElementById('generation-filters');
        const typeFiltersContainer = document.getElementById('type-filters');
        const backToTopBtn = document.getElementById('back-to-top');

        // --- ESTADO DA APLICAÇÃO ---
        let masterPokemonList = []; // Lista mestra de todos os Pokémon
        let pokemonCache = new Map(); // Cache para dados das cartas TCG
        let userCollection = {}; // Coleção do usuário (favoritos, capturados, etc.)
        let currentPokemonList = []; // Lista atualmente exibida
        let activeTab = 'all';
        let activeSort = 'pokedex_number';
        let activeFilters = { generations: new Set(), types: new Set() };
        let userId = null;
        let db;
        let auth;
        let collectionUnsubscribe = null; // Função para cancelar o listener do Firestore

        // --- CONFIGURAÇÃO DO FIREBASE ---
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'pokedex-tcg-app-default';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : { apiKey: "YOUR_API_KEY", authDomain: "...", projectId: "..." };
        
        try {
            const app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);
        } catch (error) {
            console.error("Erro ao inicializar o Firebase:", error);
            loadingIndicator.innerHTML = '<p class="text-red-400">Erro de configuração. Não foi possível conectar ao banco de dados.</p>';
        }

        // --- AUTENTICAÇÃO E DADOS DO USUÁRIO ---
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                userId = user.uid;
                loadUserCollection();
            } else {
                try {
                    if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                        await signInWithCustomToken(auth, __initial_auth_token);
                    } else {
                        await signInAnonymously(auth);
                    }
                } catch (error) {
                    console.error("Erro na autenticação anônima:", error);
                }
            }
        });

        function getCollectionRef() {
            if (!userId) return null;
            return doc(db, 'artifacts', appId, 'users', userId, 'collection', 'data');
        }

        async function loadUserCollection() {
            if (collectionUnsubscribe) collectionUnsubscribe(); // Cancela listener anterior
            const docRef = getCollectionRef();
            if (!docRef) return;

            collectionUnsubscribe = onSnapshot(docRef, (docSnap) => {
                if (docSnap.exists()) {
                    userCollection = docSnap.data();
                } else {
                    userCollection = {};
                }
                if(masterPokemonList.length > 0) {
                    renderPokemonGrid();
                }
            }, (error) => {
                console.error("Erro ao ouvir a coleção:", error);
            });
        }

        async function saveUserCollection() {
            const docRef = getCollectionRef();
            if (!docRef) return;
            try {
                await setDoc(docRef, userCollection);
            } catch (error) {
                console.error("Erro ao salvar a coleção:", error);
            }
        }
        
        // --- LÓGICA PRINCIPAL ---
        async function fetchMasterList() {
            loadingIndicator.style.display = 'flex';
            try {
                const response = await fetch(`${POKEAPI_BASE_URL}/pokemon-species?limit=1010`);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const data = await response.json();
                
                masterPokemonList = data.results.map(pokemon => {
                    const urlParts = pokemon.url.split('/');
                    const id = parseInt(urlParts[urlParts.length - 2]);
                    return {
                        name: pokemon.name,
                        pokedex_number: id,
                        generation: getGenerationFromId(id)
                    };
                });
                
                initializeUI();
                renderPokemonGrid();

            } catch (error) {
                console.error("Falha ao buscar lista de Pokémon:", error);
                loadingIndicator.innerHTML = '<p class="text-red-400">Não foi possível carregar os Pokémon. Tente recarregar a página.</p>';
            } finally {
                loadingIndicator.style.display = 'none';
            }
        }

        function getGenerationFromId(id) {
            for (const gen in GENERATIONS) {
                const { offset, limit } = GENERATIONS[gen];
                if (id > offset && id <= offset + limit) {
                    return parseInt(gen);
                }
            }
            return null;
        }

        function renderPokemonGrid() {
            grid.innerHTML = '';
            let filteredList = filterPokemonList();
            sortPokemonList(filteredList);
            currentPokemonList = filteredList;

            if(currentPokemonList.length === 0) {
                grid.innerHTML = `<p class="col-span-full text-center text-gray-400 py-10">Nenhum Pokémon encontrado com os critérios selecionados.</p>`;
                return;
            }
            
            currentPokemonList.forEach(pokemon => {
                const card = createPokemonCardElement(pokemon);
                grid.appendChild(card);
            });
        }

        function filterPokemonList() {
            const searchTerm = searchInput.value.toLowerCase().trim();

            return masterPokemonList.filter(pokemon => {
                const matchesSearch = searchTerm === '' ||
                    pokemon.name.toLowerCase().includes(searchTerm) ||
                    pokemon.pokedex_number.toString().includes(searchTerm);
                if (!matchesSearch) return false;

                const status = userCollection[pokemon.pokedex_number]?.status;
                const matchesTab = activeTab === 'all' ||
                    (activeTab === 'favorites' && status === 'favorito') ||
                    (activeTab === 'captured' && status === 'capturado') ||
                    (activeTab === 'wishlist' && status === 'desejo');
                if (!matchesTab) return false;

                if (activeFilters.generations.size > 0 && !activeFilters.generations.has(pokemon.generation)) {
                    return false;
                }

                if (activeFilters.types.size > 0) {
                    const cachedCard = pokemonCache.get(pokemon.pokedex_number);
                    if (!cachedCard || !cachedCard.types) return true;
                    const cardTypes = new Set(cachedCard.types.map(t => t));
                    const filterTypes = new Set(activeFilters.types);
                    const intersection = new Set([...cardTypes].filter(x => filterTypes.has(x)));
                    if (intersection.size === 0) return false;
                }

                return true;
            });
        }

        function sortPokemonList(list) {
            list.sort((a, b) => {
                if (activeSort === 'alphabetical') {
                    return a.name.localeCompare(b.name);
                }
                return a.pokedex_number - b.pokedex_number;
            });
        }

        function createPokemonCardElement(pokemon) {
            const card = document.createElement('div');
            card.className = 'card-container bg-gray-800 rounded-lg shadow-md overflow-hidden transform hover:-translate-y-1 transition-all duration-300 relative border-2 border-transparent';
            card.dataset.pokemonId = pokemon.pokedex_number;
            card.dataset.pokemonName = pokemon.name;

            const status = userCollection[pokemon.pokedex_number]?.status;
            if (status) {
                card.classList.add(`status-border-${status}`);
            }

            card.innerHTML = `
                <div class="w-full h-48 bg-gray-700 flex items-center justify-center image-placeholder">
                    <div class="loader-small" style="width: 30px; height: 30px; border-width: 3px; border-top-color: #facc15; animation: spin 1s linear infinite; border-radius: 50%;"></div>
                </div>
                <img class="pokemon-image w-full h-48 object-cover hidden" alt="${pokemon.name}" loading="lazy">
                <div class="p-3">
                    <h3 class="font-bold text-md truncate">${pokemon.name.charAt(0).toUpperCase() + pokemon.name.slice(1)}</h3>
                    <p class="text-sm text-gray-400">#${pokemon.pokedex_number.toString().padStart(3, '0')}</p>
                </div>
                <button class="action-menu-btn absolute top-2 right-2 bg-gray-900/50 p-1 rounded-full text-white hover:bg-gray-900/80">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path d="M10 6a2 2 0 110-4 2 2 0 010 4zM10 12a2 2 0 110-4 2 2 0 010 4zM10 18a2 2 0 110-4 2 2 0 010 4z" /></svg>
                </button>
                <div class="action-menu hidden absolute top-10 right-2 bg-gray-700 rounded-md shadow-lg z-10 text-sm py-1">
                    <a href="#" class="action-item block px-4 py-2 hover:bg-gray-600" data-action="info">Info</a>
                    <a href="#" class="action-item block px-4 py-2 hover:bg-gray-600" data-action="favorite">Favorito</a>
                    <a href="#" class="action-item block px-4 py-2 hover:bg-gray-600" data-action="capture">Capturado</a>
                    <a href="#" class="action-item block px-4 py-2 hover:bg-gray-600" data-action="wish">Desejo</a>
                    <a href="#" class="action-item block px-4 py-2 hover:bg-gray-600" data-action="switch_version">Trocar Versão</a>
                </div>
                <div class="info-overlay hidden absolute inset-0 bg-black/70 p-3 flex flex-col justify-center items-center text-center"></div>
            `;
            
            const observer = new IntersectionObserver((entries, obs) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        loadCardDetails(entry.target);
                        obs.unobserve(entry.target);
                    }
                });
            }, { rootMargin: '200px' });

            observer.observe(card);
            addCardEventListeners(card);
            return card;
        }

        async function loadCardDetails(cardElement) {
            const pokemonId = parseInt(cardElement.dataset.pokemonId);
            const pokemonName = cardElement.dataset.pokemonName;
            const userArtUrl = userCollection[pokemonId]?.artUrl;

            if (pokemonCache.has(pokemonId) && !userArtUrl) {
                updateCardUI(cardElement, pokemonCache.get(pokemonId));
                return;
            }

            try {
                let cardData;
                if (userArtUrl && pokemonCache.has(pokemonId)) {
                     cardData = pokemonCache.get(pokemonId);
                     cardData.images.small = userArtUrl;
                } else {
                    // *** CORREÇÃO: Simplificada a query da API para ser mais confiável ***
                    const response = await fetch(`${TCG_API_BASE_URL}?q=nationalPokedexNumbers:${pokemonId}`, {
                        headers: { 'X-Api-Key': TCG_API_KEY }
                    });
                    if (!response.ok) throw new Error('TCG API response not OK');
                    const result = await response.json();
                    
                    if (result.data && result.data.length > 0) {
                        cardData = result.data[0];
                        if(userArtUrl) cardData.images.small = userArtUrl;
                        pokemonCache.set(pokemonId, cardData);
                    } else {
                        throw new Error('No card found for this Pokédex number');
                    }
                }
                updateCardUI(cardElement, cardData);

            } catch (error) {
                const imgElement = cardElement.querySelector('.pokemon-image');
                const placeholder = cardElement.querySelector('.image-placeholder');
                imgElement.src = `https://placehold.co/300x420/2d3748/9ca3af?text=${pokemonName}`;
                imgElement.classList.remove('hidden');
                placeholder.style.display = 'none';
                console.warn(`Não foi possível carregar a carta para ${pokemonName} (ID: ${pokemonId}):`, error.message);
            }
        }

        function updateCardUI(cardElement, cardData) {
            const imgElement = cardElement.querySelector('.pokemon-image');
            const placeholder = cardElement.querySelector('.image-placeholder');
            
            imgElement.src = cardData.images.small;
            imgElement.onload = () => {
                imgElement.classList.remove('hidden');
                placeholder.style.display = 'none';
            };
            imgElement.onerror = () => {
                imgElement.src = `https://placehold.co/300x420/2d3748/9ca3af?text=Error`;
                imgElement.classList.remove('hidden');
                placeholder.style.display = 'none';
            };

            if (activeFilters.types.size > 0) {
                const cardTypes = new Set(cardData.types || []);
                const filterTypes = activeFilters.types;
                const intersection = new Set([...cardTypes].filter(x => filterTypes.has(x)));
                if (intersection.size === 0) {
                    cardElement.style.display = 'none';
                }
            }
        }
        
        function addCardEventListeners(card) {
            const menuBtn = card.querySelector('.action-menu-btn');
            const menu = card.querySelector('.action-menu');
            const img = card.querySelector('.pokemon-image');
            const pokemonId = parseInt(card.dataset.pokemonId);

            menuBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                document.querySelectorAll('.action-menu').forEach(m => {
                    if (m !== menu) m.classList.add('hidden');
                });
                menu.classList.toggle('hidden');
            });
            
            menu.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                const action = e.target.dataset.action;
                if(action) handleCardAction(action, card);
                menu.classList.add('hidden');
            });

            img.addEventListener('click', () => {
                const imageViewer = document.getElementById('image-viewer-modal');
                const fullscreenImage = document.getElementById('fullscreen-image');
                const cardData = pokemonCache.get(pokemonId);
                fullscreenImage.src = cardData?.images?.large || img.src;
                imageViewer.classList.remove('hidden');
            });
        }
        
        async function handleCardAction(action, card) {
            const pokemonId = parseInt(card.dataset.pokemonId);
            const pokemonName = card.dataset.pokemonName;
            const currentStatus = userCollection[pokemonId]?.status;
            let newStatus = null;

            card.classList.remove('status-border-favorito', 'status-border-capturado', 'status-border-desejo');

            switch(action) {
                case 'favorite': newStatus = currentStatus === 'favorito' ? null : 'favorito'; break;
                case 'capture': newStatus = currentStatus === 'capturado' ? null : 'capturado'; break;
                case 'wish': newStatus = currentStatus === 'desejo' ? null : 'desejo'; break;
                case 'info': toggleInfoOverlay(card); return;
                case 'switch_version': openVersionSwitcher(pokemonId, pokemonName); return;
            }

            if (newStatus) {
                if (!userCollection[pokemonId]) userCollection[pokemonId] = {};
                userCollection[pokemonId].status = newStatus;
                card.classList.add(`status-border-${newStatus}`);
            } else {
                if (userCollection[pokemonId]) {
                    delete userCollection[pokemonId].status;
                    if(Object.keys(userCollection[pokemonId]).length === 0) {
                        delete userCollection[pokemonId];
                    }
                }
            }
            
            await saveUserCollection();
            if(activeTab !== 'all') {
                renderPokemonGrid();
            }
        }
        
        async function toggleInfoOverlay(card) {
            const overlay = card.querySelector('.info-overlay');
            if (!overlay.classList.contains('hidden')) {
                overlay.classList.add('hidden');
                return;
            }

            const pokemonId = parseInt(card.dataset.pokemonId);
            const cardData = pokemonCache.get(pokemonId);
            const pokemonData = masterPokemonList.find(p => p.pokedex_number === pokemonId);

            overlay.innerHTML = '<div class="loader-small" style="width: 20px; height: 20px; border-width: 2px; border-top-color: #facc15; animation: spin 1s linear infinite; border-radius: 50%;"></div>';
            overlay.classList.remove('hidden');

            const generation = pokemonData.generation;
            const types = cardData?.types?.join(', ') || 'Carregando...';
            
            overlay.innerHTML = `
                <p><span class="font-bold text-yellow-400">Geração:</span> ${generation}</p>
                <p><span class="font-bold text-yellow-400">Tipos:</span> ${types}</p>
            `;
            
            setTimeout(() => overlay.classList.add('hidden'), 4000);
        }

        async function openVersionSwitcher(pokemonId, pokemonName) {
            const panel = document.getElementById('version-switcher-panel');
            const grid = document.getElementById('version-grid');
            grid.innerHTML = '<div class="col-span-full flex justify-center"><div class="loader"></div></div>';
            panel.classList.remove('hidden');

            try {
                const response = await fetch(`${TCG_API_BASE_URL}?q=nationalPokedexNumbers:${pokemonId}`, {
                    headers: { 'X-Api-Key': TCG_API_KEY }
                });
                if (!response.ok) throw new Error('TCG API response not OK');
                const result = await response.json();

                grid.innerHTML = '';
                if (result.data && result.data.length > 0) {
                    result.data.forEach(cardVersion => {
                        const versionCard = document.createElement('img');
                        versionCard.src = cardVersion.images.small;
                        versionCard.alt = cardVersion.name;
                        versionCard.className = 'w-full h-auto rounded-md cursor-pointer hover:scale-105 hover:shadow-lg transition-transform';
                        versionCard.onclick = async () => {
                            if (!userCollection[pokemonId]) userCollection[pokemonId] = {};
                            userCollection[pokemonId].artUrl = cardVersion.images.small;
                            await saveUserCollection();
                            
                            const mainCard = document.querySelector(`.card-container[data-pokemon-id='${pokemonId}']`);
                            if (mainCard) {
                                const mainImg = mainCard.querySelector('.pokemon-image');
                                mainImg.src = cardVersion.images.small;
                            }
                            panel.classList.add('hidden');
                        };
                        grid.appendChild(versionCard);
                    });
                } else {
                    grid.innerHTML = '<p class="col-span-full text-center">Nenhuma outra versão encontrada.</p>';
                }
            } catch (error) {
                grid.innerHTML = '<p class="col-span-full text-center text-red-400">Erro ao buscar versões.</p>';
            }
        }

        function initializeUI() {
            tabs.addEventListener('click', (e) => {
                if (e.target.classList.contains('tab-btn')) {
                    document.querySelectorAll('.tab-btn').forEach(btn => {
                        btn.classList.remove('text-yellow-400', 'border-yellow-400');
                    });
                    e.target.classList.add('text-yellow-400', 'border-yellow-400');
                    activeTab = e.target.dataset.tab;
                    renderPokemonGrid();
                }
            });
            document.querySelector('.tab-btn[data-tab="all"]').click();

            searchInput.addEventListener('input', () => {
                clearTimeout(searchInput.timer);
                searchInput.timer = setTimeout(renderPokemonGrid, 300);
            });

            sortSelect.addEventListener('change', () => {
                activeSort = sortSelect.value;
                renderPokemonGrid();
            });

            initializeFilterModal();
            filterBtn.addEventListener('click', () => filterModal.classList.remove('hidden'));
            filterModal.addEventListener('click', (e) => {
                if (e.target === filterModal) filterModal.classList.add('hidden');
            });
            applyFiltersBtn.addEventListener('click', () => {
                filterModal.classList.add('hidden');
                renderPokemonGrid();
            });
            resetFiltersBtn.addEventListener('click', () => {
                activeFilters.generations.clear();
                activeFilters.types.clear();
                document.querySelectorAll('#generation-filters button, #type-filters button').forEach(b => b.classList.remove('bg-yellow-400', 'text-gray-900'));
                filterModal.classList.add('hidden');
                renderPokemonGrid();
            });

            window.addEventListener('scroll', () => {
                if (window.scrollY > 300) {
                    backToTopBtn.classList.remove('hidden');
                } else {
                    backToTopBtn.classList.add('hidden');
                }
            });
            backToTopBtn.addEventListener('click', () => window.scrollTo({ top: 0, behavior: 'smooth' }));

            document.getElementById('close-version-switcher').addEventListener('click', () => {
                document.getElementById('version-switcher-panel').classList.add('hidden');
            });
            
            document.body.addEventListener('click', () => {
                 document.querySelectorAll('.action-menu').forEach(m => m.classList.add('hidden'));
            });
        }
        
        function initializeFilterModal() {
            Object.keys(GENERATIONS).forEach(gen => {
                const btn = document.createElement('button');
                btn.className = 'filter-option-btn p-2 border border-gray-600 rounded-md text-sm hover:border-yellow-400 transition-colors';
                btn.textContent = `Gen ${gen}`;
                btn.dataset.filterType = 'generations';
                btn.dataset.value = gen;
                generationFiltersContainer.appendChild(btn);
            });
            TYPES.forEach(type => {
                const btn = document.createElement('button');
                btn.className = 'filter-option-btn p-2 border border-gray-600 rounded-md text-sm hover:border-yellow-400 transition-colors';
                btn.textContent = type;
                btn.dataset.filterType = 'types';
                btn.dataset.value = type;
                typeFiltersContainer.appendChild(btn);
            });

            filterModal.addEventListener('click', (e) => {
                if (e.target.classList.contains('filter-option-btn')) {
                    const btn = e.target;
                    const filterType = btn.dataset.filterType;
                    const value = btn.dataset.filterType === 'generations' ? parseInt(btn.dataset.value) : btn.dataset.value;

                    if (activeFilters[filterType].has(value)) {
                        activeFilters[filterType].delete(value);
                        btn.classList.remove('bg-yellow-400', 'text-gray-900');
                    } else {
                        activeFilters[filterType].add(value);
                        btn.classList.add('bg-yellow-400', 'text-gray-900');
                    }
                }
            });
        }

        document.addEventListener('DOMContentLoaded', fetchMasterList);

    </script>
</body>
</html>
