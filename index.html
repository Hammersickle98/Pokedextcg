<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pokédex TCG</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Google Fonts: Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- Phosphor Icons -->
    <script src="https://unpkg.com/@phosphor-icons/web"></script>

    <!-- PWA Manifest -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#111827">

    <style>
        /* Estilos personalizados e tema escuro */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0f172a; /* Azul-marinho/Cinza escuro */
            color: #e2e8f0;
        }
        /* Cor de destaque principal */
        .accent-color { color: #facc15; /* Amarelo Vibrante */ }
        .bg-accent-color { background-color: #facc15; }
        .border-accent-color { border-color: #facc15; }

        /* Scrollbar customizada */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #1e293b; }
        ::-webkit-scrollbar-thumb { background: #475569; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #64748b; }

        /* Animação de carregamento */
        .loader {
            width: 48px;
            height: 48px;
            border: 5px solid #FFF;
            border-bottom-color: #facc15;
            border-radius: 50%;
            display: inline-block;
            box-sizing: border-box;
            animation: rotation 1s linear infinite;
        }
        @keyframes rotation {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Classes para estados das cartas */
        .captured-border { box-shadow: 0 0 0 3px #22c55e, 0 0 10px #22c55e; } /* Verde com brilho */
        .wish-border { box-shadow: 0 0 0 3px #a855f7, 0 0 10px #a855f7; } /* Roxo com brilho */
        
        /* Esconde o menu de ações por padrão */
        .actions-menu { display: none; }
        .pokemon-card:hover .actions-menu, .pokemon-card.actions-open .actions-menu { display: block; }

        /* Garante que o overlay de info não cause hover no card */
        .info-overlay { pointer-events: none; }
        .pokemon-card:hover .info-overlay.info-active {
            opacity: 1;
        }

    </style>
</head>
<body class="antialiased">

    <!-- Cabeçalho Fixo -->
    <header class="bg-slate-800/80 backdrop-blur-sm sticky top-0 z-40 w-full border-b border-slate-700">
        <div class="max-w-screen-2xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex items-center justify-between h-16">
                <div class="flex items-center">
                    <img src="https://assets.pokemon.com/assets/cms2/img/pokedex/full/025.png" alt="Pikachu icon" class="h-10 w-10 mr-2"/>
                    <h1 class="text-xl sm:text-2xl font-bold accent-color tracking-tight">Pokédex TCG</h1>
                </div>
                <div class="flex-1 flex justify-center px-2 lg:ml-6 lg:justify-end">
                    <div class="max-w-lg w-full lg:max-w-xs">
                        <label for="search" class="sr-only">Buscar</label>
                        <div class="relative text-gray-400 focus-within:text-gray-200">
                            <div class="pointer-events-none absolute inset-y-0 left-0 pl-3 flex items-center">
                                <i class="ph ph-magnifying-glass text-lg"></i>
                            </div>
                            <input id="search" class="block w-full bg-slate-700 border border-transparent rounded-md py-2 pl-10 pr-3 leading-5 text-gray-200 placeholder-gray-400 focus:outline-none focus:bg-slate-600 focus:border-slate-500 focus:ring-slate-500 sm:text-sm" placeholder="Buscar Pokémon..." type="search">
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </header>

    <!-- Navegação Principal -->
    <nav class="bg-slate-800 border-b border-slate-700">
        <div id="nav-tabs" class="max-w-screen-2xl mx-auto px-4 sm:px-6 lg:px-8 flex justify-center space-x-4 sm:space-x-8">
            <button data-filter="all" class="nav-tab active-tab font-medium text-sm sm:text-base whitespace-nowrap py-3 px-1 border-b-2 border-accent-color text-accent-color">Todos</button>
            <button data-filter="captured" class="nav-tab text-slate-400 hover:text-white font-medium text-sm sm:text-base whitespace-nowrap py-3 px-1 border-b-2 border-transparent">Capturados</button>
            <button data-filter="favorites" class="nav-tab text-slate-400 hover:text-white font-medium text-sm sm:text-base whitespace-nowrap py-3 px-1 border-b-2 border-transparent">Favoritos</button>
            <button data-filter="wish" class="nav-tab text-slate-400 hover:text-white font-medium text-sm sm:text-base whitespace-nowrap py-3 px-1 border-b-2 border-transparent">Desejo</button>
        </div>
    </nav>

    <!-- Conteúdo Principal -->
    <main class="max-w-screen-2xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        <!-- Controles de Paginação e Exibição -->
        <div id="controls-container" class="flex flex-col sm:flex-row justify-between items-center mb-6 gap-4">
            <div class="flex items-center gap-2">
                <label for="items-per-page" class="text-sm text-slate-400">Exibir:</label>
                <select id="items-per-page" class="bg-slate-700 border border-slate-600 rounded-md text-sm py-1 px-2 focus:ring-accent-color focus:border-accent-color">
                    <option value="40">40</option>
                    <option value="60">60</option>
                    <option value="100">100</option>
                    <option value="all">Todos (Scroll Infinito)</option>
                </select>
            </div>
            <div id="pagination-controls" class="flex items-center gap-2"></div>
        </div>

        <!-- Grade de Pokémon -->
        <div id="pokedex-grid" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 xl:grid-cols-6 2xl:grid-cols-7 gap-4 sm:gap-6">
            <!-- Cards de Pokémon serão inseridos aqui -->
        </div>

        <!-- Mensagem de Status/Erro -->
        <div id="status-message" class="w-full text-center py-10 hidden"></div>

        <!-- Indicador de Carregamento -->
        <div id="loader-container" class="w-full flex justify-center py-10">
            <div class="loader"></div>
        </div>
    </main>
    
    <!-- Modal de Visualização de Imagem -->
    <div id="image-modal" class="fixed inset-0 bg-black/80 z-50 hidden items-center justify-center p-4 cursor-pointer" onclick="this.style.display='none'">
        <img id="modal-image" src="" alt="Visualização da carta" class="max-w-full max-h-full object-contain rounded-lg shadow-2xl">
    </div>

    <!-- Botão Voltar ao Topo -->
    <button id="back-to-top" class="fixed bottom-5 right-5 bg-accent-color text-slate-900 rounded-full p-3 shadow-lg hidden transition-opacity duration-300 hover:bg-yellow-300 z-30">
        <i class="ph ph-arrow-up text-2xl"></i>
    </button>

    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, onSnapshot, setDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- CONFIGURAÇÃO E INICIALIZAÇÃO ---
        // IMPORTANTE: A API do Pokémon TCG pode exigir uma chave para uso em produção.
        // Obtenha uma em https://dev.pokemontcg.io/ e coloque-a aqui.
        const TCG_API_KEY = ""; // Deixar em branco pode funcionar para desenvolvimento, mas pode falhar.
        
        const firebaseConfig = typeof __firebase_config !== 'undefined' && __firebase_config ? JSON.parse(__firebase_config) : {};
        let app, auth, db;
        let firebaseEnabled = false;

        if (Object.keys(firebaseConfig).length > 0) {
            try {
                app = initializeApp(firebaseConfig);
                auth = getAuth(app);
                db = getFirestore(app);
                firebaseEnabled = true;
            } catch (error) {
                console.error("Falha ao inicializar o Firebase:", error);
            }
        } else {
            console.warn("Configuração do Firebase não encontrada. A funcionalidade de coleção está desativada.");
        }


        // --- VARIÁVEIS DE ESTADO GLOBAL ---
        let state = {
            userId: null,
            pokemonData: [], // Array com todos os dados dos Pokémon
            userCollection: {}, // { 'pokedexId': { captured: bool, favorite: bool, wish: bool, version: 0 } }
            currentFilter: 'all',
            searchTerm: '',
            currentPage: 1,
            itemsPerPage: 40,
            totalPokemon: 0,
            isLoading: false,
            isAuthReady: false,
            isInfiniteScroll: false,
            allDataLoaded: false
        };

        // --- ELEMENTOS DO DOM ---
        const grid = document.getElementById('pokedex-grid');
        const loader = document.getElementById('loader-container');
        const searchInput = document.getElementById('search');
        const navTabsContainer = document.getElementById('nav-tabs');
        const backToTopBtn = document.getElementById('back-to-top');
        const imageModal = document.getElementById('image-modal');
        const modalImage = document.getElementById('modal-image');
        const paginationControls = document.getElementById('pagination-controls');
        const itemsPerPageSelect = document.getElementById('items-per-page');
        const statusMessage = document.getElementById('status-message');

        // --- FUNÇÕES PRINCIPAIS ---

        /**
         * Inicializa a autenticação anônima do Firebase se estiver habilitado.
         */
        function initAuth() {
            if (!firebaseEnabled) return;
            onAuthStateChanged(auth, user => {
                if (user) {
                    state.userId = user.uid;
                    state.isAuthReady = true;
                    console.log('Usuário autenticado anonimamente:', state.userId);
                    listenToCollectionChanges();
                } else {
                    signInAnonymously(auth).catch(error => console.error("Erro na autenticação anônima:", error));
                }
            });
        }

        /**
         * Ouve por mudanças na coleção do usuário no Firestore.
         */
        function listenToCollectionChanges() {
            if (!state.userId || !firebaseEnabled) return;
            const docRef = doc(db, "pokedex_collections", state.userId);
            onSnapshot(docRef, (doc) => {
                if (doc.exists()) {
                    state.userCollection = doc.data().pokemon_status || {};
                } else {
                    // O documento será criado na primeira vez que algo for salvo.
                }
                // Re-renderiza a grade para aplicar os status da coleção (bordas, etc.).
                renderGrid();
            });
        }

        /**
         * Salva o estado da coleção do usuário no Firebase.
         */
        async function saveCollectionToFirebase() {
            if (!state.userId || !state.isAuthReady || !firebaseEnabled) return;
            try {
                const docRef = doc(db, "pokedex_collections", state.userId);
                await setDoc(docRef, { pokemon_status: state.userCollection }, { merge: true });
            } catch (error) {
                console.error("Erro ao salvar coleção:", error);
            }
        }

        /**
         * Busca a lista de espécies de Pokémon e suas cartas TCG.
         */
        async function fetchPokemonData() {
            if (state.isLoading || state.allDataLoaded) return;
            state.isLoading = true;
            showLoader(true);
            showStatusMessage(false);

            try {
                // Usando PokeAPI para uma lista confiável e ordenada de Pokémon.
                const speciesResponse = await fetch(`https://pokeapi.co/api/v2/pokemon?limit=${state.itemsPerPage}&offset=${(state.currentPage - 1) * state.itemsPerPage}`);
                if (!speciesResponse.ok) throw new Error(`PokeAPI respondeu com status ${speciesResponse.status}`);
                const speciesData = await speciesResponse.json();
                
                state.totalPokemon = speciesData.count;
                if(state.pokemonData.length >= state.totalPokemon && state.totalPokemon > 0) {
                    state.allDataLoaded = true;
                    showLoader(false);
                    return;
                }

                const pokemonPromises = speciesData.results.map(async (pokemon) => {
                    // Usando o nome do Pokémon para buscar na API TCG.
                    // A busca por nome exato entre aspas é mais precisa.
                    const tcgResponse = await fetch(`https://api.pokemontcg.io/v2/cards?q=name:"${pokemon.name}"&orderBy=-set.releaseDate`, {
                        headers: TCG_API_KEY ? { 'X-Api-Key': TCG_API_KEY } : {}
                    });
                    if (!tcgResponse.ok) {
                         console.warn(`TCG API falhou para ${pokemon.name} com status ${tcgResponse.status}`);
                         return null; // Ignora este Pokémon se a API TCG falhar
                    }
                    const tcgData = await tcgResponse.json();

                    if (tcgData.data && tcgData.data.length > 0) {
                        const speciesDetails = await fetch(pokemon.url).then(res => res.json());
                        const generationDetails = await fetch(speciesDetails.species.url).then(res => res.json());
                        const genUrlParts = generationDetails.generation.url.split('/');
                        const genNumber = genUrlParts[genUrlParts.length - 2];

                        return {
                            id: speciesDetails.id.toString(),
                            name: speciesDetails.name.charAt(0).toUpperCase() + speciesDetails.name.slice(1).replace(/-/g, ' '),
                            cards: tcgData.data.slice(0, 2).map(card => ({ // Pega no máximo 2 cartas
                                imageUrl: card.images.small,
                                largeImageUrl: card.images.large,
                                types: card.types || []
                            })),
                            generation: `Gen ${genNumber}`
                        };
                    }
                    return null;
                });

                const newPokemon = (await Promise.all(pokemonPromises)).filter(p => p !== null);
                
                if (state.isInfiniteScroll) {
                    state.pokemonData.push(...newPokemon);
                } else {
                    state.pokemonData = newPokemon;
                }
                
                // Garante a ordem correta
                state.pokemonData.sort((a,b) => parseInt(a.id) - parseInt(b.id));

                if (state.pokemonData.length === 0 && !state.searchTerm) {
                    showStatusMessage(true, "Não foi possível carregar os Pokémon. A API pode estar indisponível ou uma chave de API pode ser necessária.", true);
                }

            } catch (error) {
                console.error("Erro ao buscar dados dos Pokémon:", error);
                showStatusMessage(true, `Falha ao carregar os dados: ${error.message}. Tente recarregar a página.`, true);
            } finally {
                state.isLoading = false;
                showLoader(false);
            }
        }

        /**
         * Filtra e ordena os Pokémon com base no estado atual.
         */
        function getFilteredPokemon() {
             // Se não for scroll infinito, os dados já estão paginados pela API
            if (!state.isInfiniteScroll && !state.searchTerm && state.currentFilter === 'all') {
                return state.pokemonData;
            }

            // Para filtros, busca, ou scroll infinito, precisamos de todos os dados carregados até agora.
            // Esta é uma simplificação. Uma implementação completa exigiria carregar todos os pokemons para filtrar.
            // Por enquanto, o filtro funcionará nos dados já visíveis.
            let filtered = [...state.pokemonData];

            if (state.searchTerm) {
                filtered = filtered.filter(p => 
                    p.name.toLowerCase().includes(state.searchTerm.toLowerCase()) || 
                    p.id.toString() === state.searchTerm
                );
            }

            switch (state.currentFilter) {
                case 'captured':
                    return filtered.filter(p => state.userCollection[p.id]?.captured);
                case 'favorites':
                    return filtered.filter(p => state.userCollection[p.id]?.favorite);
                case 'wish':
                    return filtered.filter(p => state.userCollection[p.id]?.wish);
                default:
                    return filtered;
            }
        }

        /**
         * Renderiza a grade de Pokémon.
         */
        function renderGrid() {
            if (state.isInfiniteScroll && state.currentPage > 1) {
                // modo de apêndice para scroll infinito
            } else {
                grid.innerHTML = '';
            }

            const pokemonToRender = getFilteredPokemon();
            
            if (pokemonToRender.length === 0 && !state.isLoading) {
                 showStatusMessage(true, "Nenhum Pokémon encontrado para os filtros atuais.");
                 updatePagination(0);
                 return;
            } else {
                showStatusMessage(false);
            }

            const fragment = document.createDocumentFragment();
            pokemonToRender.forEach(pokemon => {
                // Evita duplicatas no modo de scroll infinito
                if (!grid.querySelector(`.pokemon-card[data-id="${pokemon.id}"]`)) {
                    const cardEl = createPokemonCard(pokemon);
                    fragment.appendChild(cardEl);
                }
            });
            grid.appendChild(fragment);
            
            if (!state.isInfiniteScroll) {
                const totalItemsForPagination = state.currentFilter === 'all' && !state.searchTerm ? state.totalPokemon : pokemonToRender.length;
                updatePagination(totalItemsForPagination);
            }
        }

        function createPokemonCard(pokemon) {
            const status = state.userCollection[pokemon.id] || {};
            const currentVersion = status.version || 0;
            const cardData = pokemon.cards[currentVersion];

            if (!cardData) return document.createDocumentFragment();

            const cardClasses = ['pokemon-card', 'relative', 'group', 'bg-slate-800', 'rounded-lg', 'overflow-hidden', 'shadow-md', 'transition-all', 'duration-300', 'hover:-translate-y-1'];
            if (status.captured) cardClasses.push('captured-border');
            else if (status.wish) cardClasses.push('wish-border');

            const card = document.createElement('div');
            card.className = cardClasses.join(' ');
            card.dataset.id = pokemon.id;

            const typeBadges = cardData.types.map(type => `<span class="text-xs font-semibold px-2 py-1 bg-slate-600 rounded-full">${type}</span>`).join('');

            card.innerHTML = `
                <img src="${cardData.imageUrl}" alt="${pokemon.name}" class="w-full h-auto cursor-pointer aspect-[245/342]" loading="lazy" onerror="this.onerror=null;this.src='https://placehold.co/245x342/1e293b/e2e8f0?text=Error';">
                <div class="p-3">
                    <h3 class="font-bold text-base truncate">${pokemon.name}</h3>
                    <p class="text-sm text-slate-400">#${pokemon.id.toString().padStart(4, '0')}</p>
                </div>
                
                <button class="absolute top-2 right-2 bg-slate-900/50 rounded-full p-1.5 text-white hover:bg-slate-900/80 z-20" data-action="toggle-menu">
                    <i class="ph ph-dots-three text-xl"></i>
                </button>
                <div class="actions-menu absolute top-10 right-2 bg-slate-900 rounded-md shadow-lg z-20 w-48 p-2">
                    <div class="absolute -top-2 right-3 w-4 h-4 bg-slate-900 transform rotate-45"></div>
                    <ul class="space-y-1">
                        <li><button data-action="info" class="w-full text-left flex items-center gap-3 px-3 py-2 text-sm rounded-md hover:bg-slate-700"><i class="ph ph-info"></i> Informação</button></li>
                        <li><button data-action="captured" class="w-full text-left flex items-center gap-3 px-3 py-2 text-sm rounded-md hover:bg-slate-700"><i class="ph ph-check-circle ${status.captured ? 'text-green-400' : ''}"></i> Capturado</button></li>
                        <li><button data-action="favorite" class="w-full text-left flex items-center gap-3 px-3 py-2 text-sm rounded-md hover:bg-slate-700"><i class="ph ph-heart ${status.favorite ? 'text-red-400' : ''}"></i> Favorito</button></li>
                        <li><button data-action="wish" class="w-full text-left flex items-center gap-3 px-3 py-2 text-sm rounded-md hover:bg-slate-700"><i class="ph ph-star ${status.wish ? 'text-purple-400' : ''}"></i> Desejo</button></li>
                        ${pokemon.cards.length > 1 ? `<li><button data-action="switch" class="w-full text-left flex items-center gap-3 px-3 py-2 text-sm rounded-md hover:bg-slate-700"><i class="ph ph-arrows-clockwise"></i> Trocar Versão</button></li>` : ''}
                    </ul>
                </div>

                <div class="info-overlay absolute inset-0 bg-black/70 p-4 flex flex-col justify-center items-center text-center opacity-0 transition-opacity z-10">
                     <p class="font-bold text-lg">${pokemon.generation}</p>
                     <div class="flex flex-wrap gap-2 mt-2 justify-center">${typeBadges}</div>
                </div>
            `;
            
            return card;
        }
        
        function updatePagination(totalItems) {
            paginationControls.innerHTML = '';
            if (state.isInfiniteScroll || totalItems === 0) return;

            const totalPages = Math.ceil(totalItems / state.itemsPerPage);
            if (totalPages <= 1) return;

            const page = state.currentPage;
            let paginationHTML = `
                <button data-page="${page - 1}" class="px-3 py-1 rounded-md bg-slate-700 hover:bg-slate-600 disabled:opacity-50 disabled:cursor-not-allowed" ${page === 1 ? 'disabled' : ''}>Anterior</button>
                <span class="text-sm text-slate-400">Página ${page} de ${totalPages}</span>
                <button data-page="${page + 1}" class="px-3 py-1 rounded-md bg-slate-700 hover:bg-slate-600 disabled:opacity-50 disabled:cursor-not-allowed" ${page === totalPages ? 'disabled' : ''}>Próxima</button>
            `;
            paginationControls.innerHTML = paginationHTML;
        }

        function handleGridClick(e) {
            const target = e.target;
            const card = target.closest('.pokemon-card');
            if (!card) return;

            const pokemonId = card.dataset.id;
            const action = target.closest('[data-action]')?.dataset.action;

            document.querySelectorAll('.pokemon-card.actions-open').forEach(openCard => {
                if (openCard !== card) openCard.classList.remove('actions-open');
            });

            if (action) {
                e.stopPropagation();
                const status = state.userCollection[pokemonId] || {};
                
                switch (action) {
                    case 'toggle-menu': card.classList.toggle('actions-open'); break;
                    case 'info': card.querySelector('.info-overlay').classList.toggle('info-active'); break;
                    case 'captured':
                        status.captured = !status.captured;
                        if(status.captured) status.wish = false;
                        updatePokemonStatus(pokemonId, status);
                        break;
                    case 'favorite':
                        status.favorite = !status.favorite;
                        updatePokemonStatus(pokemonId, status);
                        break;
                    case 'wish':
                        status.wish = !status.wish;
                        if(status.wish) status.captured = false;
                        updatePokemonStatus(pokemonId, status);
                        break;
                    case 'switch':
                        const pokemon = state.pokemonData.find(p => p.id === pokemonId);
                        status.version = ((status.version || 0) + 1) % pokemon.cards.length;
                        updatePokemonStatus(pokemonId, status);
                        break;
                }
                if (action !== 'toggle-menu' && action !== 'info') {
                    card.classList.remove('actions-open');
                }
            } else if (target.tagName === 'IMG') {
                const pokemon = state.pokemonData.find(p => p.id === pokemonId);
                const status = state.userCollection[pokemonId] || {};
                const currentVersion = status.version || 0;
                modalImage.src = pokemon.cards[currentVersion].largeImageUrl;
                imageModal.style.display = 'flex';
            }
        }
        
        function updatePokemonStatus(pokemonId, newStatus) {
            state.userCollection[pokemonId] = newStatus;
            saveCollectionToFirebase();
            const cardToUpdate = grid.querySelector(`.pokemon-card[data-id="${pokemonId}"]`);
            if (cardToUpdate) {
                const newCard = createPokemonCard(state.pokemonData.find(p => p.id === pokemonId));
                cardToUpdate.replaceWith(newCard);
            }
            if (state.currentFilter !== 'all') {
                renderGrid();
            }
        }
        
        function showLoader(show) { loader.style.display = show ? 'flex' : 'none'; }
        function showStatusMessage(show, message = "", isError = false) {
            statusMessage.style.display = show ? 'block' : 'none';
            statusMessage.textContent = message;
            statusMessage.className = `w-full text-center py-10 ${isError ? 'text-red-400' : 'text-slate-400'}`;
        }
        
        const observer = new IntersectionObserver(async (entries) => {
            if (entries[0].isIntersecting && state.isInfiniteScroll && !state.isLoading && !state.allDataLoaded) {
                state.currentPage++;
                await fetchPokemonData();
                renderGrid(); // Append new data
            }
        }, { rootMargin: '400px' });

        async function initialLoad() {
            await fetchPokemonData();
            renderGrid();
            if (state.isInfiniteScroll) {
                observer.observe(loader);
            }
        }

        // --- EVENT LISTENERS ---
        
        let debounceTimer;
        searchInput.addEventListener('input', (e) => {
            clearTimeout(debounceTimer);
            debounceTimer = setTimeout(async () => {
                state.searchTerm = e.target.value;
                state.currentPage = 1;
                state.pokemonData = []; // Limpa dados para nova busca
                grid.innerHTML = '';
                if(state.searchTerm){
                    // Lógica de busca pode ser adaptada para chamar a API diretamente
                    showStatusMessage(true, `Buscando por "${state.searchTerm}"...`);
                    const tcgResponse = await fetch(`https://api.pokemontcg.io/v2/cards?q=name:"${state.searchTerm}*"&orderBy=-set.releaseDate`, {
                        headers: TCG_API_KEY ? { 'X-Api-Key': TCG_API_KEY } : {}
                    });
                    const tcgData = await tcgResponse.json();
                    const searchResults = tcgData.data.map(card => ({
                        id: card.nationalPokedexNumbers ? card.nationalPokedexNumbers[0].toString() : card.id,
                        name: card.name,
                        cards: [{ imageUrl: card.images.small, largeImageUrl: card.images.large, types: card.types || [] }],
                        generation: '?'
                    }));
                    state.pokemonData = searchResults;
                    renderGrid();
                } else {
                    await initialLoad();
                }
            }, 500);
        });

        navTabsContainer.addEventListener('click', (e) => {
            if (e.target.classList.contains('nav-tab')) {
                document.querySelector('.nav-tab.active-tab')?.classList.remove('active-tab', 'text-accent-color', 'border-accent-color');
                document.querySelector('.nav-tab.active-tab')?.classList.add('text-slate-400', 'border-transparent');
                
                e.target.classList.add('active-tab', 'text-accent-color', 'border-accent-color');
                e.target.classList.remove('text-slate-400', 'border-transparent');
                
                state.currentFilter = e.target.dataset.filter;
                state.currentPage = 1;
                // Para filtros, idealmente teríamos todos os dados. Por simplicidade, filtra o que já foi carregado.
                // Uma implementação avançada buscaria todos os IDs da coleção e depois os dados das cartas.
                renderGrid();
            }
        });
        
        paginationControls.addEventListener('click', async (e) => {
            if (e.target.tagName === 'BUTTON' && e.target.dataset.page) {
                state.currentPage = parseInt(e.target.dataset.page);
                await fetchPokemonData();
                renderGrid();
                window.scrollTo({ top: 0, behavior: 'smooth' });
            }
        });
        
        itemsPerPageSelect.addEventListener('change', async (e) => {
            const value = e.target.value;
            state.isInfiniteScroll = value === 'all';
            state.itemsPerPage = value === 'all' ? 40 : parseInt(value);
            state.currentPage = 1;
            state.pokemonData = [];
            state.allDataLoaded = false;
            
            paginationControls.style.display = state.isInfiniteScroll ? 'none' : 'flex';
            
            if (state.isInfiniteScroll) observer.observe(loader);
            else observer.unobserve(loader);

            await initialLoad();
        });

        grid.addEventListener('click', handleGridClick);

        window.onscroll = () => {
            if (document.body.scrollTop > 200 || document.documentElement.scrollTop > 200) {
                backToTopBtn.style.display = "block";
            } else {
                backToTopBtn.style.display = "none";
            }
        };
        backToTopBtn.addEventListener('click', () => window.scrollTo({ top: 0, behavior: 'smooth' }));

        // --- INICIALIZAÇÃO ---
        initialLoad();
        if (firebaseEnabled) {
            initAuth();
        }
    </script>
    
    <script>
        const manifest = {
            "name": "Pokédex TCG", "short_name": "PokéTCG", "start_url": ".", "display": "standalone",
            "background_color": "#0f172a", "theme_color": "#111827",
            "description": "Um app moderno para gerenciar sua coleção de Pokémon TCG.",
            "icons": [
                { "src": "https://assets.pokemon.com/assets/cms2/img/pokedex/full/025.png", "sizes": "192x192", "type": "image/png" },
                { "src": "https://assets.pokemon.com/assets/cms2/img/pokedex/full/025.png", "sizes": "512x512", "type": "image/png" }
            ]
        };
        const blob = new Blob([JSON.stringify(manifest)], {type: 'application/json'});
        const manifestURL = URL.createObjectURL(blob);
        document.querySelector('link[rel="manifest"]').setAttribute('href', manifestURL);
    </script>
</body>
</html>
